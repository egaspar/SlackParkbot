using System;
using System.Diagnostics;
using System.Reflection;
using System.Web;
/// <summary>
/// Contains utility functionality that is used throughout services
/// </summary>
public static class Utilities
{
	#region Declarations

	/// <summary>
	/// Do not use this variable directly, use the App property.
	/// </summary>
	private static Module m_app;

	#endregion Declarations

	#region System Information Methods

	/// <summary>
	/// Gets the calling assembly's module.
	/// </summary>
	public static Module App
	{
		get
		{
			// In a library we use GetCallingAssembly
			if (m_app == null)
			{
				if (Assembly.GetEntryAssembly() == null)
				{
					if (HttpContext.Current != null)
					{
						try
						{
							// if we're in a web app, then the application instance will be the global.asax file
							// and the BaseType of that is the one that we define (as opposed to the one generated by ASP.NET)
							// so this ends up getting StarNet.StarRez.Web.Main.dll etc.
							m_app = HttpContext.Current.ApplicationInstance.GetType().BaseType.Module;
						}
						catch
						{
							m_app = null;
						}
					}
					if (m_app == null)
					{
						m_app = Assembly.GetCallingAssembly().GetModules()[0];
					}
				}
				else
				{
					m_app = Assembly.GetEntryAssembly().GetModules()[0];
				}
			}
			return m_app;
		}
	}

	/// <summary>
	/// Gets the application's name.
	/// </summary>
	public static string GetAppName()
	{
		return App.Name.Replace("StarNet.", "");
	}

	private static Assembly GetWebEntryAssembly()
	{
		if (HttpContext.Current == null || HttpContext.Current.ApplicationInstance == null)
		{
			return null;
		}

		Type type = HttpContext.Current.ApplicationInstance.GetType();

		while (type != null && type.Namespace.Equals("ASP", StringComparison.Ordinal))
		{
			type = type.BaseType;
		}

		return type?.Assembly;
	}

	/// <summary>
	/// Gets a detailed version to display to the user.
	/// </summary>
	/// <param name="assemblyName">The name of the assembly to get the version for.</param>
	public static string GetVersionDisplayDetailed(string assemblyName)
	{
		FileVersionInfo version = FileVersionInfo.GetVersionInfo(assemblyName);
		return "v" + version.FileMajorPart.ToString() + "." + version.FileMinorPart.ToString();
	}

	/// <summary>
	/// Gets the operating system name.
	/// </summary>
	public static string GetOSType()
	{
		// Get the Operating System From Environment Class
		OperatingSystem os = Environment.OSVersion;
		Version version = os.Version;
		string osName = version.ToString();

		switch (os.Platform)
		{
			case PlatformID.Win32Windows:
			{
				if (version.Minor == 0)
				{
					osName = "Windoze 95";
				}
				else if (version.Minor >= 1 && version.Minor <= 89)
				{
					osName = "Windows 98";
				}
				else if (version.Minor > 90)
				{
					osName = "Windows Me";
				}
				break;
			}
			case PlatformID.Win32NT:
			{
				if (version.Major == 6)
				{
					if (version.Minor == 1)
					{
						osName = "Windows 7";
					}
					else if (version.Minor == 2)
					{
						osName = "Windows 8";
					}
					else
					{
						osName = "Windows Vista";
					}
				}
				else if (version.Major == 5)
				{
					if (version.Minor == 0)
					{
						osName = "Windows 2000";
					}
					else
					{
						osName = "Windows XP";
					}
				}
				else
				{
					osName = "Windows NT";
				}
				break;
			}
		}

		return osName;
	}

	#endregion System Information Methods

	#region IsBlah Methods

	/// <summary>
	/// Checks whether the supplied string is numeric.
	/// </summary>
	/// <param name="text">The string to check.</param>
	/// <returns>True if the supplied string is numeric, false otherwise.</returns>
	public static bool IsNumeric(object text)
	{
		if (text == null)
			throw new ArgumentNullException("text");

		// I just grabbed this off some blog, it needs to be checked
		//return (System.Text.RegularExpressions.Regex.IsMatch(text, "^[-0-9]*.[.0-9].[0-9]*$"));
		//return (System.Text.RegularExpressions.Regex.IsMatch(text, @"[+|-]{0,1}[\d]{1,}(\.\d){0,1}[\d]{0,}"));
		//return (System.Text.RegularExpressions.Regex.IsMatch(text, @"(^[-+]?\d+(,?\d*)*\.?\d*([Ee][-+]\d*)?$)|(^[-+]?\d?(,?\d*)*\.\d+([Ee][-+]\d*)?$)"));
		/* I (Dave) updated it to use the Framework, so we dont need to worry about languages.
		   Checked with the following results:
			 "1.25" = True
			 "-1.25" = True
			 "(1.25)" = False
			 "$1.25" = False
			 "1" = True
			 "asdf" = "False"
			 "1,123.23" = "True"
		*/
		double dRet;
		return Double.TryParse(text.ToString(), System.Globalization.NumberStyles.Number, System.Globalization.CultureInfo.CurrentCulture.NumberFormat, out dRet);
	}

	#endregion IsBlah Methods

	#region Remote Desktop

	[System.Runtime.InteropServices.DllImport("Wtsapi32.dll")]
	private static extern bool WTSQuerySessionInformation(System.IntPtr hServer, int sessionId, WTS_INFO_CLASS wtsInfoClass, out System.IntPtr ppBuffer, out uint pBytesReturned);

	private enum WTS_INFO_CLASS
	{
		WTSInitialProgram,
		WTSApplicationName,
		WTSWorkingDirectory,
		WTSOEMId,
		WTSSessionId,
		WTSUserName,
		WTSWinStationName,
		WTSDomainName,
		WTSConnectState,
		WTSClientBuildNumber,
		WTSClientName,
		WTSClientDirectory,
		WTSClientProductId,
		WTSClientHardwareId,
		WTSClientAddress,
		WTSClientDisplay,
		WTSClientProtocolType
	}

	/// <summary>
	/// If the user is connected via terminal services then then this method will return their workstation machine name.
	/// </summary>
	/// <returns>Workstation Machine Name</returns>
	public static string GetTerminalServerClientName()
	{
		const int WTS_CURRENT_SERVER_HANDLE = -1;

		IntPtr buffer = IntPtr.Zero;
		uint bytesReturned;

		string strReturnValue = string.Empty;
		try
		{
			WTSQuerySessionInformation(IntPtr.Zero, WTS_CURRENT_SERVER_HANDLE, WTS_INFO_CLASS.WTSClientName, out buffer, out bytesReturned);
			strReturnValue = System.Runtime.InteropServices.Marshal.PtrToStringAnsi(buffer);
		}
		finally
		{
			buffer = IntPtr.Zero;
		}

		return strReturnValue;
	}

	#endregion Remote Desktop
}
